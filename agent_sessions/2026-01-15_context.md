# Success Library - Project Context

## What We're Building

The Success Library is a centralized repository that defines how marketing campaign success is measured. The problem it solves is simple: right now, every time someone runs a campaign analysis, they write their own code to calculate success metrics. There's no single source of truth. One analyst might define "activation" one way, another analyst defines it differently. Metrics are scattered across tech specs, Confluence pages, and individual scripts. This creates inconsistency, makes auditing difficult, and wastes time.

The Success Library changes that. It's a governed collection of metric definitions with the actual code attached. When someone needs to measure acquisition success for a Virtual Visa Debit campaign, they don't write their own logic from scratch. They go to the library, find the metric, and use the standardized code that everyone else uses.

## Why This Matters

The organization runs hundreds of marketing campaigns. Each campaign needs to be measured. Without standardization, you get chaos: different definitions, different methodologies, results that can't be compared across campaigns. The Success Library creates consistency. It also creates speed - instead of spending time figuring out how to calculate a metric, analysts can focus on the actual analysis.

There's another dimension to this. Eventually, the plan is to have a curated data layer where these metrics are pre-calculated and running on a schedule. When that exists, campaign measurement becomes trivial - you just link your campaign to the existing metric and the data is already there. But even then, the original code doesn't become useless. It becomes documentation. It tells you exactly what that pre-calculated metric is based on. It's the audit trail, the lineage, the thing you point to when someone asks "how is this number calculated?"

## The Pilot

We're starting small with the Virtual Visa Debit product. VVD has six campaigns: VCN and VDA for acquisition, VDT for activation, VUT and VAW for provisioning, and VUI for usage. Each campaign maps to a success metric. The pilot creates the structure and proves the concept before expanding to other products.

The structure is straightforward. There's a metadata file that serves as the index - it contains all the information about each metric: what it's called, what product it belongs to, what type of metric it is, where the data comes from, who owns it. Then there's the code itself, stored as SQL files. The metadata points to the code. When you look up a metric, you see the definition and you can grab the code.

We're also building a simple HTML interface so people can browse and search the library without digging through files. Search for "VVD" and you see all the VVD metrics. Click on one and you can view and copy the code. It's meant to be practical - not fancy, just functional.

## Technical Decisions

The code is written in SQL. The long-term target platform is Snowflake, and SQL is platform-agnostic enough to work on Teradata now and migrate later. SQL is also more accessible - more people on the team know SQL than PySpark. When processing power is needed, PySpark can wrap the SQL, but the core logic stays in SQL.

Version control is handled through Git. Every change is tracked. The metadata has a version field for human-readable labels, but the real audit trail is in the commit history. This gives us governance - changes can be reviewed before they go live.

## What's Next

The structure is in place. The metadata template exists. The SQL files exist as placeholders. The next work is filling in the actual content: the business definitions that explain what each metric means in plain language, the source tables that specify where the data comes from, and the SQL logic that performs the calculation. The HTML interface also needs work - the current card-based design is too verbose and needs to be simplified to a clean table format.

This is a pilot. It's meant to prove the concept and establish patterns that can scale. Once VVD is complete, the same structure extends to other products. The library grows, but the architecture stays the same.
